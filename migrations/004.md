–û—Ç–ª–∏—á–Ω–æ. –ü—Ä–∏—Å—Ç—É–ø–∞–µ–º –∫ **TASK-P1-02**.

–Ø –Ω–∞—á–Ω—É —Å –ø–µ—Ä–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ —Å–ø–∏—Å–∫–µ: `Core/continue-command-handler.mdc`.

–Ø –≤—ã–ø–æ–ª–Ω—é –¥–≤–µ –∑–∞–¥–∞—á–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ:
1.  **–ü–µ—Ä–µ–≤–µ–¥—É** –≤—Å–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π —è–∑—ã–∫.
2.  **–ê–±—Å—Ç—Ä–∞–≥–∏—Ä—É—é** –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ-–∑–∞–≤–∏—Å–∏–º—ã–µ –∫–æ–º–∞–Ω–¥—ã (`grep`, `wc`, `sed`) –≤ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø—Å–µ–≤–¥–æ–∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –æ–ø–∏—Å—ã–≤–∞–µ—Ç *–Ω–∞–º–µ—Ä–µ–Ω–∏–µ*.

–í–æ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

`edit_file`
`./.cursor/rules/isolation_rules/Core/continue-command-handler.mdc`
```mdc
---
description: "Defines the system for handling a 'CONTINUE' command, providing intelligent context restoration or suggesting next steps if the session is new or a task is already active."
globs: "**/**"
alwaysApply: true
---

# CONTINUE COMMAND HANDLER SYSTEM

> **TL;DR:** This system intelligently handles a `CONTINUE` command. It analyzes the previous system state to resume work on an active task. If the context is empty, it analyzes the Memory Bank for available tasks and provides the user with relevant options.

## üîÑ PRINCIPLES OF THE CONTINUE HANDLER

### Core Requirements
- **Intelligent Context Restoration**: Analyze the previous system state, restore active tasks and projects, and identify the last working mode to resume from the stopping point.
- **Empty Chat Handling**: If the chat is empty, check for active or pending tasks in the Memory Bank, analyze recent activity, and provide the user with a list of available modes and recommended next actions.

## üéØ CONTINUE COMMAND PROCESSING ALGORITHM

### Main Handling Workflow

```
// Pseudocode for the main 'CONTINUE' command handler.
function handle_continue_command() {
  print("üîÑ PROCESSING 'CONTINUE' COMMAND")
  print("==============================")

  // 1. Analyze the system state to determine the context.
  system_state = analyze_system_state()
  print("üìä System state: " + system_state)

  // 2. Route to the appropriate handler based on the state.
  switch (system_state) {
    case "active_task":
      handle_active_task_continuation()
      break
    case "empty_chat_with_tasks":
      handle_empty_chat_continuation()
      break
    case "interrupted_session":
      handle_interrupted_session_continuation()
      break
    case "new_session":
      handle_new_session_continuation()
      break
    default:
      handle_unknown_state()
      break
  }
}
```

### System State Analysis

```
// Pseudocode for analyzing the current state of the Memory Bank.
function analyze_system_state() {
  // Use the Task Artifact Manager to get canonical paths.
  active_task_path = get_active_task_path()

  // 1. Check for a currently active task.
  if (is_not_empty(active_task_path)) {
    return "active_task"
  }

  // 2. If no active task, check if any tasks exist at all.
  todo_tasks = find_files_in_directory(get_task_artifact_path("todo_dir"))
  in_progress_tasks = find_files_in_directory(get_task_artifact_path("in_progress_dir"))

  if (todo_tasks.length > 0 || in_progress_tasks.length > 0) {
    // This state indicates the user can choose a task to start.
    return "empty_chat_with_tasks"
  }

  // 3. Check for signs of a previous, but not currently active, session.
  // This could be based on recently modified files in the memory-bank.
  last_activity_timestamp = get_last_modified_timestamp("memory-bank/")
  if (is_recent(last_activity_timestamp)) {
    return "interrupted_session"
  }

  // 4. If none of the above, it's a new session.
  return "new_session"
}
```

## üìã ACTIVE TASK CONTINUATION

### Resuming an Active Task

```
// Pseudocode for handling continuation when an active task is found.
function handle_active_task_continuation() {
  print("üìã ACTIVE TASK DETECTED")
  print("========================")

  // 1. Get the path to the active task's primary file.
  task_file_path = get_task_file_path() // from task-artifact-manager

  // 2. Extract key information from the task file.
  task_info = extract_task_info(task_file_path)
  print("üìù Active Task: " + task_info.name)
  print("üìä Status: " + task_info.status)

  // 3. Analyze progress and determine next steps.
  progress_analysis = analyze_task_progress(task_info)
  print("üìà Progress Analysis:" + progress_analysis)

  next_steps = determine_next_steps(task_info)
  print("üéØ Recommended Next Steps:" + next_steps)

  // 4. Offer relevant modes to the user.
  print("\nüîß Available modes to continue:")
  print("1. IMPLEMENT - Continue implementation")
  print("2. PLAN - Re-evaluate the plan")
  print("3. QA - Run quality assurance checks")
  print("4. REFLECT - Analyze completed work")

  // 5. Automatically recommend a mode based on context.
  recommended_mode = recommend_mode_for_task(task_info.status)
  print("üí° Recommended mode: " + recommended_mode)

  user_choice = prompt_user("Select a mode (1-4) or press Enter for recommended: ")

  selected_mode = user_choice or recommended_mode
  start_mode(selected_mode, task_info.name)
}
```

## üí≠ EMPTY CHAT CONTINUATION

### Handling an Empty Chat with Existing Tasks

```
// Pseudocode for when the chat is empty but tasks exist in the Memory Bank.
function handle_empty_chat_continuation() {
  print("üí≠ EMPTY CHAT DETECTED")
  print("========================")

  // 1. Find all available tasks.
  all_tasks = find_all_tasks() // Searches todo/ and in_progress/ directories

  if (all_tasks.length > 0) {
    print("üìã Found tasks in Memory Bank:")
    display_tasks(all_tasks) // Present tasks to the user

    // 2. Offer choices for how to proceed.
    print("\nüîÑ How would you like to continue?")
    print("1. Resume the most recently modified task")
    print("2. Select a task from the list")
    print("3. Create a new task")
    print("4. Analyze project state (VAN mode)")

    continuation_choice = prompt_user("Select an option (1-4): ")

    switch (continuation_choice) {
      case "1":
        resume_last_active_task()
        break
      case "2":
        select_task_from_list(all_tasks)
        break
      case "3":
        create_new_task() // from task-management-2-0
        break
      case "4":
        start_mode("VAN")
        break
      default:
        print("‚ùå Invalid choice. Starting VAN mode for analysis.")
        start_mode("VAN")
        break
    }
  } else {
    // This case should be handled by 'new_session' state.
    handle_new_session_continuation()
  }
}
```

## üîç ANALYSIS AND RECOMMENDATIONS

### Determining Next Steps & Recommending Modes

```
// Pseudocode for the logic that powers recommendations.
function determine_next_steps(task_info) {
  // Logic to analyze task status, completion percentage, and checklists
  // to generate a list of actionable next steps.
  // Example:
  if (task_info.status == "PLANNED") {
    return ["1. Begin implementation (IMPLEMENT)", "2. Detail the plan further (PLAN)"]
  }
  if (task_info.status == "IN_PROGRESS" and task_info.completion < 50) {
    return ["1. Continue implementation (IMPLEMENT)", "2. Run tests on completed parts (QA)"]
  }
  // ... more logic ...
}

function recommend_mode_for_task(task_status) {
  // Logic to suggest the most appropriate mode.
  // Example:
  if (task_status.contains("PLANNED")) {
    return "IMPLEMENT"
  }
  if (task_status.contains("IN_PROGRESS")) {
    return "IMPLEMENT"
  }
  if (task_status.contains("COMPLETED")) {
    return "REFLECT"
  }
  if (task_status.contains("ERROR") or task_status.contains("BLOCKED")) {
    return "CREATIVE" // For problem-solving
  }
  return "VAN" // Default for analysis
}
```

This system provides an intelligent and user-friendly way to maintain context and workflow continuity within the Memory Bank.
```

–§–∞–π–ª `Core/continue-command-handler.mdc` —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –∏ –∞–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞–Ω. –í—Å–µ —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∏ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è `bash` –∫–æ–º–∞–Ω–¥—ã –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –ø—Å–µ–≤–¥–æ–∫–æ–¥.

–ì–æ—Ç–æ–≤—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ñ–∞–π–ª—É?